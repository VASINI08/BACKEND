# backend_portfolio.py
# This file manages all database interactions for the portfolio tracker.
# It uses psycopg2 for PostgreSQL connectivity.

import psycopg2
import uuid
import datetime

# --- Database Connection Details ---
# IMPORTANT: Replace these with your PostgreSQL connection details.
DB_NAME = "ABCD"
DB_USER = "postgres"
DB_PASSWORD = "Vasini@2013"
DB_HOST = "localhost"
DB_PORT = "5433"

def get_db_connection():
    """Establishes and returns a database connection."""
    try:
        conn = psycopg2.connect(
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT
        )
        return conn
    except psycopg2.OperationalError as e:
        print(f"Error connecting to database: {e}")
        return None

def create_tables():
    """Creates the 'assets' and 'transactions' tables if they don't exist."""
    conn = get_db_connection()
    if not conn:
        return
    cur = conn.cursor()
    try:
        cur.execute("""
            CREATE TABLE IF NOT EXISTS assets (
                asset_id VARCHAR(255) PRIMARY KEY,
                ticker VARCHAR(50) NOT NULL,
                asset_type VARCHAR(50) NOT NULL,
                purchase_date DATE NOT NULL,
                shares DECIMAL(15, 6) NOT NULL,
                cost_basis DECIMAL(15, 2) NOT NULL
            );
        """)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS transactions (
                transaction_id VARCHAR(255) PRIMARY KEY,
                asset_id VARCHAR(255) REFERENCES assets(asset_id),
                transaction_date DATE NOT NULL,
                transaction_type VARCHAR(50) NOT NULL,
                amount DECIMAL(15, 2) NOT NULL,
                description TEXT
            );
        """)
        conn.commit()
    except (psycopg2.DatabaseError, Exception) as e:
        conn.rollback()
        print(f"Error creating tables: {e}")
    finally:
        cur.close()
        conn.close()

# --- CRUD Operations for Assets ---

def create_asset(ticker, asset_type, purchase_date, shares, cost_basis):
    """Inserts a new asset into the database."""
    conn = get_db_connection()
    if not conn:
        return False, "Database connection failed."
    cur = conn.cursor()
    try:
        asset_id = str(uuid.uuid4())
        cur.execute(
            """
            INSERT INTO assets (asset_id, ticker, asset_type, purchase_date, shares, cost_basis)
            VALUES (%s, %s, %s, %s, %s, %s);
            """,
            (asset_id, ticker.upper(), asset_type, purchase_date, shares, cost_basis)
        )
        conn.commit()
        return True, "Asset added successfully!"
    except (psycopg2.DatabaseError, Exception) as e:
        conn.rollback()
        return False, f"Error adding asset: {e}"
    finally:
        cur.close()
        conn.close()

def get_all_assets():
    """Fetches all assets from the database."""
    conn = get_db_connection()
    if not conn:
        return []
    cur = conn.cursor()
    try:
        cur.execute("SELECT asset_id, ticker, asset_type, purchase_date, shares, cost_basis FROM assets ORDER BY purchase_date DESC;")
        assets = cur.fetchall()
        return assets
    except (psycopg2.DatabaseError, Exception) as e:
        print(f"Error fetching assets: {e}")
        return []
    finally:
        cur.close()
        conn.close()

def update_asset(asset_id, ticker, asset_type, purchase_date, shares, cost_basis):
    """Updates an existing asset in the database."""
    conn = get_db_connection()
    if not conn:
        return False, "Database connection failed."
    cur = conn.cursor()
    try:
        cur.execute(
            """
            UPDATE assets SET ticker = %s, asset_type = %s, purchase_date = %s, shares = %s, cost_basis = %s
            WHERE asset_id = %s;
            """,
            (ticker.upper(), asset_type, purchase_date, shares, cost_basis, asset_id)
        )
        conn.commit()
        if cur.rowcount > 0:
            return True, "Asset updated successfully!"
        return False, "Asset not found."
    except (psycopg2.DatabaseError, Exception) as e:
        conn.rollback()
        return False, f"Error updating asset: {e}"
    finally:
        cur.close()
        conn.close()

def delete_asset(asset_id):
    """Deletes an asset and its associated transactions from the database."""
    conn = get_db_connection()
    if not conn:
        return False, "Database connection failed."
    cur = conn.cursor()
    try:
        # First, delete associated transactions
        cur.execute("DELETE FROM transactions WHERE asset_id = %s;", (asset_id,))
        # Then, delete the asset
        cur.execute("DELETE FROM assets WHERE asset_id = %s;", (asset_id,))
        conn.commit()
        if cur.rowcount > 0:
            return True, "Asset and its transactions deleted successfully."
        return False, "Asset not found."
    except (psycopg2.DatabaseError, Exception) as e:
        conn.rollback()
        return False, f"Error deleting asset: {e}"
    finally:
        cur.close()
        conn.close()

# --- CRUD Operations for Transactions ---

def create_transaction(asset_id, transaction_date, transaction_type, amount, description):
    """Inserts a new transaction into the database."""
    conn = get_db_connection()
    if not conn:
        return False, "Database connection failed."
    cur = conn.cursor()
    try:
        transaction_id = str(uuid.uuid4())
        cur.execute(
            """
            INSERT INTO transactions (transaction_id, asset_id, transaction_date, transaction_type, amount, description)
            VALUES (%s, %s, %s, %s, %s, %s);
            """,
            (transaction_id, asset_id, transaction_date, transaction_type, amount, description)
        )
        conn.commit()
        return True, "Transaction added successfully!"
    except (psycopg2.DatabaseError, Exception) as e:
        conn.rollback()
        return False, f"Error adding transaction: {e}"
    finally:
        cur.close()
        conn.close()

def get_all_transactions():
    """Fetches all transactions from the database, with asset ticker."""
    conn = get_db_connection()
    if not conn:
        return []
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT t.transaction_id, a.ticker, t.transaction_date, t.transaction_type, t.amount, t.description
            FROM transactions t
            JOIN assets a ON t.asset_id = a.asset_id
            ORDER BY t.transaction_date DESC;
        """)
        transactions = cur.fetchall()
        return transactions
    except (psycopg2.DatabaseError, Exception) as e:
        print(f"Error fetching transactions: {e}")
        return []
    finally:
        cur.close()
        conn.close()

# --- Analytics and Reporting ---

def get_portfolio_summary():
    """Calculates and returns a summary of the portfolio."""
    conn = get_db_connection()
    if not conn:
        return {"total_invested": 0, "total_assets": 0}
    cur = conn.cursor()
    summary = {"total_invested": 0, "total_assets": 0}
    try:
        cur.execute("SELECT COALESCE(SUM(cost_basis), 0) FROM assets;")
        summary["total_invested"] = cur.fetchone()[0]

        cur.execute("SELECT COUNT(asset_id) FROM assets;")
        summary["total_assets"] = cur.fetchone()[0]

    except (psycopg2.DatabaseError, Exception) as e:
        print(f"Error calculating summary: {e}")
    finally:
        cur.close()
        conn.close()
    return summary

def get_asset_allocation():
    """Returns the portfolio breakdown by asset class."""
    conn = get_db_connection()
    if not conn:
        return []
    cur = conn.cursor()
    try:
        cur.execute("SELECT asset_type, SUM(cost_basis) FROM assets GROUP BY asset_type;")
        allocation = cur.fetchall()
        return allocation
    except (psycopg2.DatabaseError, Exception) as e:
        print(f"Error calculating allocation: {e}")
        return []
    finally:
        cur.close()
        conn.close()

